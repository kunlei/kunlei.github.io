<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Kunlei Lian">
<meta name="dcterms.date" content="2024-08-11">

<title>Kunlei Lian - Work Experience</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../">
<script src="../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-DJ30KLH89M"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-DJ30KLH89M', { 'anonymize_ip': true});
</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../../index.html">
    <span class="navbar-title">Kunlei Lian</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../about.html"> 
<span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../../docs/blog/index.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-books" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Books</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-books">    
        <li>
    <a class="dropdown-item" href="https://kunlei.github.io/python-ortools-notes/"><i class="bi bi-book" role="img">
</i> 
 <span class="dropdown-text">OR-Tools</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://kunlei.github.io/large-scale-opt-python/"><i class="bi bi-book" role="img">
</i> 
 <span class="dropdown-text">Large-Scale Optimization</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://kunlei.github.io/approaching-vrp-java/"><i class="bi bi-book" role="img">
</i> 
 <span class="dropdown-text">Approaching VRPs</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://kunlei.github.io/metaheuristics-java/"><i class="bi bi-book" role="img">
</i> 
 <span class="dropdown-text">Metaheuristics in Action</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#marriott-vacations-worldwide" id="toc-marriott-vacations-worldwide" class="nav-link active" data-scroll-target="#marriott-vacations-worldwide">Marriott Vacations Worldwide</a>
  <ul>
  <li><a href="#associate-director-data-science" id="toc-associate-director-data-science" class="nav-link" data-scroll-target="#associate-director-data-science">Associate Director, Data Science</a>
  <ul class="collapse">
  <li><a href="#marketing-campaign-optimization" id="toc-marketing-campaign-optimization" class="nav-link" data-scroll-target="#marketing-campaign-optimization">Marketing Campaign Optimization</a></li>
  <li><a href="#existing-owner-propensity-to-repurchase" id="toc-existing-owner-propensity-to-repurchase" class="nav-link" data-scroll-target="#existing-owner-propensity-to-repurchase">Existing Owner Propensity to Repurchase</a></li>
  <li><a href="#interval-international-supplydemand-forecasting-and-channel-allocation-optimization" id="toc-interval-international-supplydemand-forecasting-and-channel-allocation-optimization" class="nav-link" data-scroll-target="#interval-international-supplydemand-forecasting-and-channel-allocation-optimization">Interval International Supply/Demand Forecasting and Channel Allocation Optimization</a></li>
  <li><a href="#loan-delinquency-forecasting" id="toc-loan-delinquency-forecasting" class="nav-link" data-scroll-target="#loan-delinquency-forecasting">Loan Delinquency Forecasting</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#walmart" id="toc-walmart" class="nav-link" data-scroll-target="#walmart">Walmart</a>
  <ul>
  <li><a href="#principal-data-scientist" id="toc-principal-data-scientist" class="nav-link" data-scroll-target="#principal-data-scientist">Principal Data Scientist</a>
  <ul class="collapse">
  <li><a href="#truckload-optimization-tlo" id="toc-truckload-optimization-tlo" class="nav-link" data-scroll-target="#truckload-optimization-tlo">Truckload optimization (TLO)</a></li>
  <li><a href="#truck-planning-optimization" id="toc-truck-planning-optimization" class="nav-link" data-scroll-target="#truck-planning-optimization">Truck planning optimization</a></li>
  <li><a href="#outbound-order-optimization" id="toc-outbound-order-optimization" class="nav-link" data-scroll-target="#outbound-order-optimization">Outbound order optimization</a></li>
  <li><a href="#network-planning-model-for-walmart-freight-planner" id="toc-network-planning-model-for-walmart-freight-planner" class="nav-link" data-scroll-target="#network-planning-model-for-walmart-freight-planner">Network planning model for Walmart Freight Planner</a></li>
  </ul></li>
  <li><a href="#staff-data-scientist" id="toc-staff-data-scientist" class="nav-link" data-scroll-target="#staff-data-scientist">Staff Data Scientist</a></li>
  <li><a href="#walmart-freight-planner" id="toc-walmart-freight-planner" class="nav-link" data-scroll-target="#walmart-freight-planner">Walmart Freight Planner</a></li>
  <li><a href="#direct-pallet-builder" id="toc-direct-pallet-builder" class="nav-link" data-scroll-target="#direct-pallet-builder">Direct Pallet Builder</a></li>
  <li><a href="#senior-data-scientist" id="toc-senior-data-scientist" class="nav-link" data-scroll-target="#senior-data-scientist">Senior Data Scientist</a>
  <ul class="collapse">
  <li><a href="#profiling-optimization" id="toc-profiling-optimization" class="nav-link" data-scroll-target="#profiling-optimization">Profiling Optimization</a></li>
  <li><a href="#ocean-procurement" id="toc-ocean-procurement" class="nav-link" data-scroll-target="#ocean-procurement">Ocean Procurement</a></li>
  </ul></li>
  <li><a href="#data-scientist" id="toc-data-scientist" class="nav-link" data-scroll-target="#data-scientist">Data Scientist</a>
  <ul class="collapse">
  <li><a href="#driver-scheduling" id="toc-driver-scheduling" class="nav-link" data-scroll-target="#driver-scheduling">Driver Scheduling</a></li>
  <li><a href="#assortment-planning" id="toc-assortment-planning" class="nav-link" data-scroll-target="#assortment-planning">Assortment Planning</a></li>
  </ul></li>
  <li><a href="#data-scientist-intern" id="toc-data-scientist-intern" class="nav-link" data-scroll-target="#data-scientist-intern">Data Scientist Intern</a>
  <ul class="collapse">
  <li><a href="#inventory-optimization" id="toc-inventory-optimization" class="nav-link" data-scroll-target="#inventory-optimization">Inventory Optimization</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Work Experience</h1>
  <div class="quarto-categories">
    <div class="quarto-category">work</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Kunlei Lian </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 11, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="marriott-vacations-worldwide" class="level2">
<h2 class="anchored" data-anchor-id="marriott-vacations-worldwide">Marriott Vacations Worldwide</h2>
<section id="associate-director-data-science" class="level3">
<h3 class="anchored" data-anchor-id="associate-director-data-science">Associate Director, Data Science</h3>
<section id="marketing-campaign-optimization" class="level4">
<h4 class="anchored" data-anchor-id="marketing-campaign-optimization">Marketing Campaign Optimization</h4>
</section>
<section id="existing-owner-propensity-to-repurchase" class="level4">
<h4 class="anchored" data-anchor-id="existing-owner-propensity-to-repurchase">Existing Owner Propensity to Repurchase</h4>
</section>
<section id="interval-international-supplydemand-forecasting-and-channel-allocation-optimization" class="level4">
<h4 class="anchored" data-anchor-id="interval-international-supplydemand-forecasting-and-channel-allocation-optimization">Interval International Supply/Demand Forecasting and Channel Allocation Optimization</h4>
</section>
<section id="loan-delinquency-forecasting" class="level4">
<h4 class="anchored" data-anchor-id="loan-delinquency-forecasting">Loan Delinquency Forecasting</h4>
</section>
</section>
</section>
<section id="walmart" class="level2">
<h2 class="anchored" data-anchor-id="walmart">Walmart</h2>
<section id="principal-data-scientist" class="level3">
<h3 class="anchored" data-anchor-id="principal-data-scientist">Principal Data Scientist</h3>
<section id="truckload-optimization-tlo" class="level4">
<h4 class="anchored" data-anchor-id="truckload-optimization-tlo">Truckload optimization (TLO)</h4>
<p><strong>Background</strong></p>
<p>Walmart has a vast inbound network consisting of thousands of vendors and close to one hundred distribution centers (DC). As part of the replenishmnet process, store-item demands are first aggregated at DC level and then orders are placed to vendors to fulfill the demands. Note that there could be many vendors replenishing the same DC and it is necessary to optimize the order quantities at each vendor such that the total transportation cost is minimized.</p>
<p>In TLO, the inbound nework is divied into hundreds of thousands of lanes and TLO is optimized at the lane level. A lane is decided by an specific vendor or vendor pool (a group of vendors), and a specific destination DC or DC pool (a group of DCs).</p>
<p><strong>Problem</strong></p>
<p>Within a given lane, there are tens or hundreds of small orders are to be put onto the trucks. Each order has an initial order quantity and the problem is to fine-tune or optimize the initial order quantities such that the truckload utilization is maximized. There are several constraints to this problem:</p>
<ul>
<li>Each order has a minimum and maximum order quantities specified and the final quantity must be within the given range.</li>
<li>Each order has an incremental order quantity specified and the increase or decrease in order quantities must be a multiple of the given incremental order quantity.</li>
<li>An order could have multiple attributes, like source vendor, destination DC and item number. It’s desired to put orders from the same vendor, or going to the same DC or containing the same item together.</li>
</ul>
<p>The objectives:</p>
<ul>
<li>maximimize truckload utilization</li>
<li>minimize vendor/DC/item split</li>
</ul>
<p><strong>Solution</strong></p>
<p>The solution is a heuristic-based approach and its overall logic is as belows:</p>
<ol type="1">
<li>Load orders with initial quantities onto trucks using the <em>load generator</em> heuristic.</li>
<li>If the last truck capacity is under-utilized (&lt; 10%), call load shinker <em>heuristic</em>.</li>
<li>If the last truck capacity is close to full (&gt; 70%), call load expander <em>heuristic</em>.</li>
</ol>
<p>The core of the optimizer is a truck loading heuristic that takes a list of orders with fixed order quantities and decides how to load them onto given number of trucks. The general logic of the algorithm is below (<em>load generator</em>):</p>
<ul>
<li>Identify the constraining capacity constraints, it’s either weight or volume</li>
<li>Sort orders in decreasing order of the constraining constraints</li>
<li>Start with one truck and load orders using first-fit heuristic.</li>
</ul>
<p>The <em>load shrinker</em> heuristic works as follows:</p>
<ul>
<li>Use a priority queue to save all the orders and sort them in <em>decreasing</em> order of their inventory level ((curr inventory + supply) / demand)</li>
<li>In an iterative process, do the following
<ul>
<li>Take an order from the top of the priority queue</li>
<li>Shrink its order quantity based on the incremental order quantity</li>
<li>Invoke the <em>load generator</em> to create truckloads</li>
<li>Stop the process if the given number of trucks are fully occupied</li>
</ul></li>
</ul>
<p>The <em>load expander</em> heuristic works as follows:</p>
<ul>
<li>Use a priority queue to save all the orders and sort them in <em>increasing</em> order of their inventory level ((curr inventory + supply) / demand)</li>
<li>In an iterative process, do the following
<ul>
<li>Take an order from the top of the priority queue</li>
<li>Expand its order quantity based on the incremental order quantity</li>
<li>Invoke the <em>load generator</em> to create truckloads</li>
<li>Stop the process if the give number of trucks are fully occupied.</li>
</ul></li>
</ul>
</section>
<section id="truck-planning-optimization" class="level4">
<h4 class="anchored" data-anchor-id="truck-planning-optimization">Truck planning optimization</h4>
<p><strong>Background</strong></p>
<p>Truck planning optimization works on a higher level than truckload optimization (TLO). In Walmart’s inbound network, multiple vendors could be aligned to the same ship point and truck capacities are procured at ship point level in long-term capacity planning and procurement. In the current environment, the volume, number of trucks, going out of a ship point could vary from day to day or week to week. Any excess demands from a ship point could create urgent needs to procure extra truckload capacities on the spot, which is generally very expensive to do.</p>
<p><strong>Problem</strong></p>
<p>The optimization problem in this project is to decide on the optimal order quantities such that the total number of trucks going out of the input ship point falls within the given range. The inputs to this problem includes:</p>
<ul>
<li>A list of orders with initial order quantity, lane information</li>
<li>The range of total number of trucks</li>
</ul>
<p><strong>Solution</strong></p>
<p>The solution uses the same <em>load generator</em> heuristic in the TLO project. The main logic consits of the following steps:</p>
<ol type="1">
<li>Build truck loads for each lane using TLO engine</li>
<li>If total number of trucks exceeds given range, shink order quantities
<ol type="1">
<li>Use priority queue of all loads generated for all lanes, sorted them in increasing order of their truckload utilization.</li>
<li>Keep dropping orders from chosen load until total number of loads falls within given range</li>
</ol></li>
<li>If total number of trucks is below given range, expan order quantities
<ol type="1">
<li>Use priority queue of all orders, sorted in increasing order of their inventory health</li>
<li>Increase order quantity for orders taken from the queue</li>
<li>Run <em>load generator</em> for the corresponding lane and re-check its load count</li>
<li>Repeat the process until the total load count falls within given range</li>
</ol></li>
</ol>
</section>
<section id="outbound-order-optimization" class="level4">
<h4 class="anchored" data-anchor-id="outbound-order-optimization">Outbound order optimization</h4>
<p><strong>Background</strong></p>
<p>In the overall replenishment process, the outbound process refers to the flow from DC to stores. The problem faced by stores is that the receiving volumes at stores vary too much, this causes a lot of problems stores. For example, if the number of loads arriving at a store is too few, store labors will be under-utilized. On the other hands, if there is excessive loads arriving at a store, extra temporary works have to be hired to unload the trucks, it is very expensive to do so and causes lots of frictions in store labor planning. It is therefore desired to have consistent replenishment flow from DC to each store.</p>
<p><strong>Problem</strong></p>
<p>The O3 solves replenishment problem The inputs to this problem consists of:</p>
<ul>
<li>A list of store-item level orders with initial order quantities</li>
<li>Input parameters
<ul>
<li>The pallet range for each store aligned to the DC</li>
<li>Regression parameters to turn orders into pallet counts</li>
<li>Planning/smoothening horizon, typically 7 days</li>
</ul></li>
</ul>
<p><strong>Solution</strong></p>
<p>There are three modules in the O3 optimizer:</p>
<ol type="1">
<li>Target volume optimizer based on MIP</li>
<li>Order shrinking heuristic</li>
<li>Order expanding heuristic</li>
</ol>
<p>In the first module, the optimal target volume is decided for each store over the given planning horizon. The problem is modeled as a network flow model and the decision variable is as follows:</p>
<ul>
<li><span class="math inline">y_{si}</span> the target volume for store <span class="math inline">s</span> on day <span class="math inline">i</span>, the volume is indicated by the pallet count.</li>
<li><span class="math inline">x_{sij}</span> the amount of volume flowing from day <span class="math inline">i</span> to day <span class="math inline">j</span> for store <span class="math inline">s</span>.</li>
</ul>
<p>The objective has the below components:</p>
<ul>
<li>to minimize the overflow of demands to the dummy day, which represents the unmet demands</li>
<li>to minimize the variation of target volume over the planning horizon for each store</li>
</ul>
<p>The constraints include:</p>
<ul>
<li>Flow conservation constraints - initial store volume is equal to all the outgoing volume, including the volume to itself.</li>
<li>The target volume is equal to the all the incoming flow to the node</li>
<li>The variation is calculated as the difference between the min and max volume across the planning horizon. Note that this is done for each store.</li>
</ul>
<p>In the second module, order quantities are shrinked for all the stores whose target volume is smaller than the initial volume. The workflow is as follows:</p>
<ul>
<li>Create and maintain a priority queue, sorted in decreasing order of the inventory health of each item</li>
<li>Repeat
<ul>
<li>Take one item from the queue, decrease its order quantity by the incremental order quantity amount</li>
<li>Recalculate the pallet count using the regression coefficient</li>
<li>Stop when the total pallet ocunt equals to the target pallet count</li>
</ul></li>
</ul>
<p>In the third module, order quantities are expanded for all the stores whose target pallet count is bigger than the initial vlume. The workflow is as follows:</p>
<ul>
<li>Create and maintain a priority queue, sorted in increasing order by the inventory health of each item</li>
<li>Repeat
<ul>
<li>Take one item from the queue, increase its order quantity by the incremental order quantity amount</li>
<li>Recalculate the pallet count using the regression coefficient</li>
<li>Stop when the total pallet ocunt equals to the target pallet count</li>
</ul></li>
</ul>
</section>
<section id="network-planning-model-for-walmart-freight-planner" class="level4">
<h4 class="anchored" data-anchor-id="network-planning-model-for-walmart-freight-planner">Network planning model for Walmart Freight Planner</h4>
<p><strong>Background</strong></p>
<p>This is part of the Walmart Freight Planner project. I was pulled into the project to help improve the performance of the WFP optimizer.</p>
<p><strong>Problem</strong></p>
<p>Given a potentially huge number of small shipments, the problem aims to identify the best set of loads and their corresponding routes such that the total transportation costs are minimized.</p>
<p><strong>Solution</strong></p>
<p>There are two steps in the network flow based solution:</p>
<ol type="1">
<li>Clustering using K-means</li>
<li>Network flow-based MIP modeling</li>
</ol>
<p>In the first step, all the inputs shipments are considered together and clustered into multiple groups. Feature considered for clustering include: - Location of shipment origins - Location of shipment destinations - Shipment weight/volume/pallets</p>
<p>K-means algorithm was used to identify the best shipment groups.</p>
<p>In the second step, each cluster is optimized separately. The algorithm works as follows:</p>
<ol type="1">
<li>Identify all the usable lanes for the shipments in the cluster
<ol type="1">
<li>lanes decide the cost structures</li>
</ol></li>
<li>Pre-compute the assignment costs of shipments onto the lanes</li>
<li>Use MIP to find the optimal assignment of shipments to lanes such that the total transportation cost is minimized.</li>
</ol>
</section>
</section>
<section id="staff-data-scientist" class="level3">
<h3 class="anchored" data-anchor-id="staff-data-scientist">Staff Data Scientist</h3>
</section>
<section id="walmart-freight-planner" class="level3">
<h3 class="anchored" data-anchor-id="walmart-freight-planner">Walmart Freight Planner</h3>
<p><strong>Background</strong></p>
<p>Walmart’s transportation network is divied into first-mile, middle middle and last middle. The first mile is concerned with transportation connecting vendors/suppliers to its DCs. There could also be consolidation centers (CC) in between. In the first-mile space, an important problem is the shipment consolidation where hundreds of thousands of small shipments have to flow from their origins (vendors) to their corresponding destinations (DCs), possibly through consolidation centers in between.</p>
<p>Walmart was using a third party vendor (Blue Yonder) to manage its inbound network. The Walmart Freight Planner (WFP) is an initiative to develop in-house optimizer to solve the shipment consolidation problems internally.</p>
<p><strong>Problem</strong></p>
<p>The inputs to this problem include:</p>
<ul>
<li>All the shipments that need to be consolidated, a shipment has several attributes attached to it:
<ul>
<li>origin + destination</li>
<li>pickup window + delivery windows</li>
<li>weight/volume/case/pallet</li>
</ul></li>
<li>All the avaialble lanes</li>
<li>All the available consolidation centers and their corresponding capacities</li>
</ul>
<p>Lane is a critical concept and information in the optimization process. It defines all the cost components that are used to calculate how many it costs to move a load. A lane is defined on many levels, it could be city to city, state to state, or zip code to zip code. There might be multiple tarriffs that could be used on a lane. A tariff acts like a contract between Walmart and a carriers. A tariff contains one or multiple tariff details. All the cost structures are defined on the tariff details. A tariff detail decides the trucks that could be used to move a load utilizing the lane. It also decides the number of stops on the lane and various rates, for example, cost per mile and anxillary charges.</p>
<p>Based on the input shipments and the available lanes, the problem is to find the optimal set of loads such that all the shipments are moved from their origins to their destinations in the most cost-efficient way. The transportation cost is the sole objective in the problem as all the load cost could be calculated from the tarriff information.</p>
<p><strong>Solution</strong></p>
<p>The overall solution consists of three modules:</p>
<p>1 Network partitioner 2 Load generator 3 Load picker</p>
<p><em>In the first module</em>, the inbound network is divided into several separate, yet potentially overlapping, sub-networks. This segmentation is heuristic based and there are multiple segmentation strategies:</p>
<ul>
<li>CP-based. Take a center point and includes all the shipments that originate within a certain miles (500 miles) in the same sub-network. It is also possible to consider multiple center points together if they are geographically close to each other.</li>
<li>DC-based. Consider DCs that are close to each other and include all the shipments going to the DCs.</li>
<li>Vendor-based. Consider vendors that are close to each other and include all the shipments originating from the vendors.</li>
</ul>
<p>It is intentional that several of the resulting segments could overlap with each other. A pure partition could make the problem easier to sovle but might miss certain optimization opportunities.</p>
<p><em>In the second module</em>, shipments within the same cluster are consolidate into loads using a column generation framework. To do this, all the available tarriffs are first identified and a set of template empty loads are generated upfront to save computational costs. Then an initial set of loads are created first with each load consisting of only one shipment. These loads are fed into a column generation solver to get the dual value of each shipment. The pricing solver is then used to create new loads. There are multiple heuristic and/or metaheuristic are used to create new loads based on the dual values.</p>
<p>Domain knowledge or business requirements could be incorporated in the load generation process. For example, for ease of operation (load tendering and execution), it’s not desirable to have loads that have more than two pickup stops. In addition, all the DC-direct loads have only one destination stops. For CP-loads, loads visiting one or more vendors and going through a center points and finally going to one or more destination DCs, the load creation heuristic would start from every vendor and tries to generate loads starting from that vendor. Similar process is followed to create DC-diret loads.</p>
<p>Note that a load might only pickup some of the shipments at a venodr location. It may also visit one or two vendor locations. One important consideration when creating new loads is time windows. It’s very critical to make sure all the loads generated are feasible with respect to the pickup and delivery time windows, and also the vendor/CP/DC operating hours. CP capacity has also to be considered.</p>
<p>Note also that all the load cost must be calculated using the tariff information associated with the loads. Since there might be multiple tarriffs available at the same vendor locations, the load generation process must consider all the available options. Therefore, the pricing problem is computation-intensive.</p>
<p><em>In the third module</em>, all the loads generated from each of the sub-network are collected and sent to the <em>load picking</em> engine to select the final set of laods. Since the number of loads generated from each of the subproblem is huge, there are two steps in the load picking:</p>
<ol type="1">
<li>Load reduction</li>
<li>Load picking.</li>
</ol>
<p>In the first step, a separate column generation process is used to reduce the number of loads to manageable sizes. For example, the solver might receive 2 millions loads and the column generation might reduce them to 0.5 million.</p>
<p>In the second step, a MIP problem is solved to select the final set of loads. During this step, we make sure that every shipment is assigned to one and only one load and all the CP capacity constraints are satisfied.</p>
</section>
<section id="direct-pallet-builder" class="level3">
<h3 class="anchored" data-anchor-id="direct-pallet-builder">Direct Pallet Builder</h3>
<p><strong>Background</strong></p>
<p>In DC operations, a critical step in the outbound process is pallet building. In grocery DCs, store item demands come in the unit of number of cases and they have to be picked manually by order-fillers and put onto pallets before putting onto trucks. The pallet building is currently a manually process that requires lots of training and labor-intensive. It takes several months for a new hire to build enough expeirence to build good pallets. One big problem with grocery DC is that lots of order-fillers quit and new hires need to be trained again. The project aims to remove the pallet building optimization part from the order fillers so that they can just follow the screen instructions instead of building up necessary experience to be efficient.</p>
<p><strong>Problem</strong></p>
<p>In this problem, we build one pallet at a time. For each pallet, we are given a number of items, each with several attributes:</p>
<ul>
<li>number of cases to be picked</li>
<li>picking order</li>
<li>weight/volume</li>
<li>can be side/end stacked or not</li>
</ul>
<p>The problem is to find the exact location of each of the cases on the pallet such that</p>
<ul>
<li>the space utilization on the pallet is maximized, and</li>
<li>the stability is maximized.</li>
</ul>
<p><strong>Solution</strong></p>
<p>The solution is a layered pallet building algorithm based on tabu search. It consists of the following process:</p>
<ul>
<li>Repeat while there are cases left
<ul>
<li>tentatively select a list of cases from the list to build the current layer</li>
<li>bundle cases together to try to create even layers</li>
<li>use tabu search to build one layer</li>
<li>install one built layer and put not-built cases back into the queue</li>
</ul></li>
</ul>
<p>The layer building algorithm based on tabu search is the key to the solution. At its core is the solution representation scheme which takes a list of case bundles with fixed orders and decides the exact locations within the same layer. To build one layer, we have to manage the three-dimensional space. Note that once a case in put in the current layer, it cuts the space into two separate yet overlapping subspaces. As we continue doing this, some spaces become too small to fit any cases and need to be removed from consideration. Some other spaces become too similar and need to be merged to speed up the computation process.</p>
</section>
<section id="senior-data-scientist" class="level3">
<h3 class="anchored" data-anchor-id="senior-data-scientist">Senior Data Scientist</h3>
<section id="profiling-optimization" class="level4">
<h4 class="anchored" data-anchor-id="profiling-optimization">Profiling Optimization</h4>
<p><strong>Background</strong></p>
<p>Grocery DC has the inbound and outbound process. In the inbound process, items coming into the DC must be placed into slots. The profiling process aims to decide the best slots to place one item.</p>
<p><strong>Problem</strong></p>
<p>There are two problems to be solved:</p>
<ol type="1">
<li>Assume it’s a brand-new DC, what is the best slot location for all the existing items. This is called profiling refresh. It tries to identify the ideal profiing solution towards which the current profiling should move.</li>
<li>Given the current profiling solution, where should be put new items coming into the DC.</li>
</ol>
<p><strong>Solution</strong></p>
<p>The inputs to the first problem are:</p>
<ul>
<li>A list of items, each with its demands</li>
<li>A list of available slots, each with its locations
<ul>
<li>distance to the docking area could be derived based on slot location</li>
</ul></li>
</ul>
<p>A MIP model was built:</p>
<ul>
<li>Decision variables: whether an item <span class="math inline">i</span> should be placed into slot <span class="math inline">s</span></li>
<li>Objective: to minimize the total traveling distances
<ul>
<li>high velocity items should be slotted closer to the loading dock</li>
</ul></li>
<li>Constraints
<ul>
<li>one item must be put into a slot</li>
<li>one slot can take at most one item</li>
</ul></li>
</ul>
<p>In the second problem, we are given:</p>
<ul>
<li>the current profiling solution, which designates the slotting location of each existing item in the GDC</li>
<li>a list of new items for which we need to find slots</li>
</ul>
<p>The objective is to minimize item movements when there is not enough slot space.</p>
<p>Constraints:</p>
<ul>
<li>each new item must have a slot</li>
<li>an existing item can be moved to a new slot but the total movements must be minimized</li>
</ul>
</section>
<section id="ocean-procurement" class="level4">
<h4 class="anchored" data-anchor-id="ocean-procurement">Ocean Procurement</h4>
<p><strong>Background</strong></p>
<p>In Walmart’s logistics space, ocean procurement refers to the process of deciding which carrier should take up the shipment volume for the upcoming fiscal year. Walmart has tens of thousands of contains that need to be moved from many countries across the globe to ten destination cities in the U.S.</p>
<p><strong>Problem</strong></p>
<p>The input units to this problem are:</p>
<ul>
<li>A list of lanes, each lane is associated with the following information
<ul>
<li>origin/destination</li>
<li>volume/weight</li>
</ul></li>
<li>A list of carrier bids for each lane
<ul>
<li>A carrier propose the number of days to move the volume and the associated costs</li>
</ul></li>
</ul>
<p>The problem is to find the carriers for each lane such that the total transportation costs are minimized.</p>
<p>The constraints include:</p>
<ul>
<li>For each lane, all the volume must be covered by selected carriers</li>
<li>For each lane, the variation in transit days must be within a given threhold. In other words, the transit days between the chosen carriers for a lane cannot be different than x number of days.</li>
<li>For each lane, the average transit days cannot increase by a certain percentage than last year.</li>
<li>The total volume assigned to a carrier cannot exceed a certain percentage</li>
<li>The toatal volume assigned to a U.S. port cannot exceed a certain percentage</li>
</ul>
<p><strong>Solution</strong></p>
</section>
</section>
<section id="data-scientist" class="level3">
<h3 class="anchored" data-anchor-id="data-scientist">Data Scientist</h3>
<section id="driver-scheduling" class="level4">
<h4 class="anchored" data-anchor-id="driver-scheduling">Driver Scheduling</h4>
<p><strong>Background</strong></p>
<p>Walmart has around 100 transportation offices, and each transportation office has to management the assignment of drivers to tractors. The goal is to make sure a driver to stay on the same tractor throughout his/her workweek. A transportation office could be managing close to 100 drivers and 100 tractors.</p>
<p><strong>Problem</strong></p>
<p>Given:</p>
<ul>
<li>a list of drivers with each driver having his/her own workweek
<ul>
<li>A workweek is derived from his/her driving program. For example, a driver could be working under a 5/2/5/3 program, which means that he works 5 days and then takes 2 days off, and then works another 5 days and takes 3 days off.</li>
</ul></li>
<li>a list of available tractors</li>
</ul>
<p>The problem is to fnd the assignment of drivers to tractors such that:</p>
<ul>
<li>tractor utilization is maximized</li>
<li>driver split is minimized</li>
</ul>
<p><strong>Solution</strong></p>
<p>The solution is a column generation based heuristic algorithm within a rolling horizon framework. Since the end user could select a range of days spanning from a few days to several months to optimize drivers’ schedule. The rolling horizion framework focuses on one day at a time and optimize drivers’s schedule continusouly.</p>
<p>Within a day, the column generation algorithm is used. The planning horizon is divided into hour segments and a workweek assignment is treated as a column. The contraints in the master problem include:</p>
<ul>
<li>A driver has to be assigned to a tractor. If such a tractor could not be found, the driver is assigned to a dummy tracotr.</li>
<li>A tractor can take at most one driver at any given hour.</li>
</ul>
<p>The mast problem will generate dual values for every dirver-hour combination and dual values from every tractor-hour combinations. The pricing problem will be generating new columns based on this information. A depth first search algorithm is used to create new columns. Basically, for every workweek, we try to create a new column considering the dual values of existing tractor-hour dual values. Split-seat is considered in this process.</p>
</section>
<section id="assortment-planning" class="level4">
<h4 class="anchored" data-anchor-id="assortment-planning">Assortment Planning</h4>
<p><strong>Background</strong></p>
<p>In Walmart stores, it has to decide what items to present on the shelf, which is called assortment planning.</p>
<p><strong>Problem</strong></p>
<p><strong>Solution</strong></p>
<p>The solution is based on the paper, specifically, on page 12 and 18:</p>
<p>Partially-Ranked Choice Models for Data-Driven Assortment Optimization, by Sanjay Dominik Jena, Andrea Lodi and Hugo Palmer</p>
<p>In the column generation algorithm, a column refers to a customer choice set. Each row in the master problem refers to an item. The decision variable is the probabily of a column.</p>
<p>objective: to minimize difference between estimated probabilty and observed probability constraints: - the total probability of all customer choices sum up to 1 - estimated probability + error = observed probability</p>
<p>The optimization problem in the second step:</p>
<p>objective: to maximize revenue constraints: - each produt can only be chosen once</p>
</section>
</section>
<section id="data-scientist-intern" class="level3">
<h3 class="anchored" data-anchor-id="data-scientist-intern">Data Scientist Intern</h3>
<section id="inventory-optimization" class="level4">
<h4 class="anchored" data-anchor-id="inventory-optimization">Inventory Optimization</h4>
<p><strong>Background</strong></p>
<p>Walmart desires a inventory optimization engine.</p>
<p><strong>Problem</strong></p>
<p>The problem is to decide on the optimal safety stock coverage (sscov) days at store-item level.</p>
<p><strong>Solution</strong></p>
<p>Use simulation-driven optimization engine.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>